local PathfindingService = game:GetService("PathfindingService")
local waypoints
local currentWaypointIndex=1
local humanoid= script.Parent.Humanoid
local config= script.Parent:WaitForChild('Config')
local agentParams = {
	AgentRadius = 0.25,
	AgentHeight = 5,
	AgentCanJump = false,
	AgentCanClimb = true}--config.Canjump.Value
--local path = PathfindingService:CreatePath()
local path = PathfindingService:CreatePath(agentParams)

nextlocation=config.Nextlocation
local pathmaker= require(workspace.clashcombat.Modules.Pathmaker)

callbackcount=0
-------------------
--waypointsmod=Instance.new('Model')
--waypointsmod.Parent=workspace
--function printwaypoints(waypoints)
--	waypointsmod:ClearAllChildren()
--	for i=1, #waypoints do
--		local new= Instance.new('Part')
--		new.Parent= waypointsmod
--		new.Anchored=true
--		new.CanCollide=false
--		new.Position= waypoints[i].Position
--		new.Shape= Enum.PartType.Ball
--		new.Material= Enum.Material.Neon
--		new.Size= Vector3.new(0.25,0.25,0.25)
--		if waypoints[currentWaypointIndex].Action==Enum.PathWaypointAction.Jump then
--			new.Color= Color3.new(1,1,0)
--		else
--			new.Color= Color3.new(1,1,1)
--		end
--	end
--end

----------------
function followPath() --error backtracks due to recursion
	if nextlocation.Value~=Vector3.new(0,0,0) then
		waypoints=nil
		waypoints = pathmaker.makepath(script.Parent.Head.Position, nextlocation.Value)
		if waypoints==nil and math.fmod(callbackcount,2)==0  then
			
			path:ComputeAsync(script.Parent.Head.Position, nextlocation.Value)
			if path.Status == Enum.PathStatus.Success then
				waypoints = path:GetWaypoints()
				
			end
		end
		if waypoints~=nil then
			callbackcount=0 
			config.movestatus.Value=1
			currentWaypointIndex = 1
			humanoid:MoveTo(waypoints[currentWaypointIndex].Position)
		else --backtracking/turn
			config.movestatus.Value=0
			callbackcount=callbackcount+1
			if callbackcount==2 then
				humanoid:MoveTo(config.Nextlocation.Value)
				wait(2)
			elseif callbackcount==3 and config.Canjump.Value==true then
				humanoid.Jump=true
				humanoid:MoveTo(config.Nextlocation.Value)
				wait(2)
			elseif callbackcount>3 and callbackcount<7 and config.Canjump.Value==true then
				humanoid.Jump=true
				humanoid:MoveTo(script.Parent.Head.Position+Vector3.new(math.random(-5,5),0,math.random(-5,5)))
				wait(2)
				if callbackcount>0 then
					humanoid:MoveTo(config.Nextlocation.Value)
				end
			else
				wait(3)
			end
			if callbackcount>0 then
				--followPath()
			end
		end
	else
		currentWaypointIndex= #waypoints
	end
end
function startfollowPath() --this follow path calls while other follow path calls resulting in npc following--multiple paths at once. )THEORY       
	
	followPath()
end
function findtarget()
	local npcs= workspace:GetChildren()
	local origin= script.Parent.Head.Position
	for i=1, #npcs do
		if string.sub(npcs[i].Name,1,3)=='NPC' then
			local target= npcs[i].Head.Position
			if npcs[i]~=script.Parent and (origin-target).Magnitude<50 then
				return(target)
			end
		end
	end
	return(nil)
end
function turntotarget(target)
	if script.Parent.Humanoid.Sit==false then
		script.Parent.HumanoidRootPart.BodyGyro.MaxTorque= Vector3.new(0,100000,0)
		script.Parent.HumanoidRootPart.BodyGyro.CFrame= CFrame.new(script.Parent.Head.Position,target)
		wait(0.5)
		script.Parent.HumanoidRootPart.BodyGyro.MaxTorque= Vector3.new(0,0,0)
	end
end
function haveachat()
	--local target= findtarget()
	--if target~=nil then
	--	turntotarget(target)
	--	talkanim()
	--end
	--talkanim()
end
function talkanim()
	local anims= script.Parent.Animation.Animations:GetChildren()
	local pickedanim= anims[math.random(1,#anims)]
	local humanoid= script.Parent.Humanoid
	local track= humanoid:LoadAnimation(pickedanim)
	track:Play()
end
function onWaypointReached(reached)
	if waypoints~=nil then
		if reached and currentWaypointIndex < #waypoints then
			currentWaypointIndex = currentWaypointIndex + 1
			humanoid:MoveTo(waypoints[currentWaypointIndex].Position)
			--elseif reached and currentWaypointIndex==#waypoints then
			--	script.Parent.Occupied.Value=false
		elseif currentWaypointIndex == #waypoints then
			config.movestatus.Value=2
			--haveachat()
		end	
	end
end

local function onPathBlocked(blockedWaypointIndex)
	if blockedWaypointIndex > currentWaypointIndex then
		followPath()
	end
end
callbackcount=0
--path.Blocked:Connect(onPathBlocked)
humanoid.MoveToFinished:Connect(onWaypointReached)
--followPath()
nextlocation.Changed:Connect(startfollowPath)

